use std::{collections::HashMap, sync::Arc};

use anyhow::format_err;
use ethereum::ReceiptV3;
use ethereum_types::{H160, H256, U256};
use serde::{Deserialize, Serialize};

use crate::{
    receipt::Receipt,
    storage::{traits::LogStorage, Storage},
    Result,
};

/// Log represents a contract log event. These events are generated by the LOG opcode
/// and stored/indexed by the node.
/// Consensus fields: address, topics, data.
/// Derived fields (filled in by node, not secured by consensus): block number, block hash,
/// tx index, tx hash, log index, removed flag.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct LogIndex {
    // Hash of the block in which the transaction was included
    pub block_hash: H256,
    // Block in which the transaction was included
    pub block_number: U256,
    // List of topics provided by the contract
    pub topics: Vec<H256>,
    // Supplied by the contract, usually ABI-encoded
    pub data: Vec<u8>,
    // Index of the log in the block
    pub log_index: U256,
    // Address of the contract that generated the event
    pub address: H160,
    // The removed field is true if this log was reverted due to a chain reorganization.
    // You must pay attention to this field if you receive logs through a filter query.
    pub removed: bool,
    // Hash of the transaction
    pub transaction_hash: H256,
    // Index of the transaction in the block
    pub transaction_index: U256,
}

pub struct LogService {
    storage: Arc<Storage>,
}

impl LogService {
    pub fn new(storage: Arc<Storage>) -> Self {
        Self { storage }
    }

    pub fn generate_logs_from_receipts(
        &self,
        receipts: &Vec<Receipt>,
        block_number: U256,
    ) -> Result<()> {
        let mut logs_map: HashMap<H160, Vec<LogIndex>> = HashMap::new();
        let mut log_index = 0_usize; // log index is a block level index
        for receipt in receipts {
            let logs = match &receipt.receipt {
                ReceiptV3::Legacy(r) | ReceiptV3::EIP2930(r) | ReceiptV3::EIP1559(r) => &r.logs,
            };

            for log in logs {
                let map = logs_map.entry(log.address).or_default();

                map.push(LogIndex {
                    block_hash: receipt.block_hash,
                    block_number,
                    topics: log.clone().topics,
                    data: log.clone().data,
                    log_index: U256::from(log_index),
                    address: log.clone().address,
                    removed: false, // hardcoded as no reorgs on DeFiChain
                    transaction_hash: receipt.tx_hash,
                    transaction_index: U256::from(receipt.tx_index),
                });

                log_index = log_index
                    .checked_add(1)
                    .ok_or_else(|| format_err!("log_index overflow"))?;
            }
        }

        for (address, logs) in logs_map {
            self.storage.put_logs(address, logs, block_number)?
        }
        Ok(())
    }
}
